# 一、索引大纲

参考：https://developer.aliyun.com/article/831250

![MySQL索引](D:\study\person_blog\数据库\索引\Mysql索引.png)


> 写在前面： 首先需要明确的一点是。 MySQL的索引？ 本质上是一种数据结构。 是一种组织数据存储的方式。 它类似于书籍的目录页。 通过索引可以快速。 定位到你需要查询的数据位置。 由于索引本身是一种数据结构，要存储这些数据结构。 是需要花费额外的存储空间的。因此索引。 用来优化查询速度的方式。 本质上是通过空间来换取时间。

MySQL 索引是一种数据结构，用于加快查询速度。它类似于书籍的目录，可以快速定位到某个关键字对应的数据行。MySQL 索引可以在查询时提供快速的访问路径，从而减少全表扫描的开销，提高查询效率。

# 二、 原理

索引是通过一种特定的数据结构来组织和存储数据，本质上他是一种对数据结构在数据存储上的运用。 比如将数据存储的时候就排好顺序。 然后以二叉树的数据结构组织起来再存储

# 三、分类

## 3.1 主键索引：

在MySQL中。 对于设置为主键的字段，会自动为其创建主键索引。 主键索引对应字段的数据不能重复。 不能为空。在innoDB存储引擎下MySQL的主键索引也叫聚簇索引。去除索引的数据存储时，其数据结构为B+树。
它的叶子节点存储的就是一整行的数据。 因此它的索引和数据是存放在一起的（聚集在一起）。主键索引 是属于单列索引的一种

## 3.2 唯一索引：

设置唯一索引的数据列其中的数据。 不能重复。 但是可以为null。 但只能有一个null。唯一索引可以是单个字段组成，也可以是多个字段组成的。 因此它既可以是单列索引也可以属于多列索引。
在多列索引的情况下，只要求他这多个字段共同组成的数据唯一即可。

## 3.3 普通索引

普通索引没有唯一值的限制。 可以重复。 可以为null。 普通索引可以是单列索引也可以是多列索引。

## 3.4 复合索引：

复合索引是由多个字段共同组成的索引。复合索引创建字段的先后顺序对数据检索时索引能够使用的效率。 有很大的影响。 复合索引建立的不好会导致索引性能变差甚至失效。 复合索引有一个通常的 建立规则，它应该遵循。最左匹配原则。

## 3.5 全文索引：

MySQL在5.6版本之后。 他的innoDB存储引擎开始支持全文索引。 在5.6之前只有myISAM存储引擎支持全文索引

MySQL中只有字符串类型的字段才能支持建立全文索引。 比如char、varchar、text类型

细节暂不展开

## 3.6 空间索引：

暂不讨论

## 3.7 前缀索引：

在文本类型为char、varchar、text类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

# 三、特性

## 3.1 优点

1. 由于索引建立的过程中对数据就已经进行了排序操作。 因此在查询数据并且进行排序的时候效率就会提升很多。 CPU不用再单独进行排序。
2. 通过索引查询数据。 不用进行全表扫描。 根据特定的索引列找到对应的数据。 可以大大的提高查询速度。

## 3.2 缺点

1. 由于索引是以单独的空间来组织存储数据，因此它会占用额外的空间。
2. 所以虽然可以提高查询的效率。 但是会降低增删改数据的效率。 原因在于每次更新数据的同时都需要单独维护索引。

因此在使用索引的过程中应该要结合它的优缺点。 索引并不是越多越好，而是在合适的场景使用合适的字段创建索引。

# 五、索引操作

```sql
-- 查看索引
show
    index from 表名;

-- 删除索引
drop index 索引名 on 表名;

-- 创建单列索引，只能包含一个字段
create index name_index on table_name (target_field);

alter table table_name
    add index name_index (target_field);

-- 创建唯一索引，只能有一个列
create unique index index_name on table_name (target_field);

alter table table_name
    add unique index_name (target_field);

-- 复合索引
create index index_name on table_name (target_field1, target_field2...);

alter table table_name
    add index index_name (target_field1, target_field2...);

```

# 六、索引演化过程

> Hash表

Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的形式存储数据。我们使用hash表存储表数据结构，Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，
时间复杂度为O(1)；但是不支持范围快速查找，范围查找时只能通过扫描全表的方式，筛选出符合条件的数据。显然，这不符合数据库对数据操作的要求。

> 排序二叉树

排序二叉树可以优化查询数据的次数。在合理选择根节点的情况下可以做到折半查找。 但是排序二叉树不总是平衡的。 当左右子树两边的高度差过大时。查找性能就会退化，甚至变成一个链表。

> 平衡二叉树

平衡二叉树。 在排序二叉树的基础之上解决了左右子树高度差过大的问题。在插入数据的过程中，通过左旋和右旋的方式保证了左右子树的高度差不会超过1。但是平衡二叉树。 仍然存在着树的整体高度可能会很大。 同时他无法满足范围查找的需求。
如果要范围查找它必须要重新从根节点遍历元素。

> B树

B树具有如下特点：

- B树的节点中存储这多个元素，每个内节点有多个分叉。
- 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点中都存储数据。
- 父节点当中的元素不会出现在子节点中。
- 所有的叶子节点都位于同一层，叶子节点具有相同的深度，叶子节点之间没有指针连接

使用B树作为索引的数据结构。 可以很大程度的降低磁盘的io次数。 但是B树仍然有很明显的局限性。

- B树不支持范围查询的快速查找，例如：仍然根据上图，我们想要查询10到35之间的数据，查找到10之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历
- 如果每个节点存储的是行记录，行的大小随着列数的增加，所占空间会变大，这时一页中可存储的数据量就会减少，树相应就会变高，磁盘IO次数就会随之增加. 这一点可以参考下面的说明理解

B树中每个节点的大小是有限制的。这个限制通常与磁盘页大小相同（数据页是MySQL加载数据的基本单位），因为B树通常用于磁盘访问。当一个节点中的数据量超过了这个限制时，它就需要分裂成两个节点。如果数据行变大，那么每个节点能够存储的数据行数量就会减少。这意味着需要更多的节点来存储相同数量的数据，从而导致树的高度增加。

## B+树

B+树，作为B树的升级版，MySQL在B树的基础上继续进行改造，使用B+树构建索引。B+树和B树最主要的区别在于**非叶子节点是否存储数据**的问题。

- B树：叶子节点和非叶子节点都会存储数据。
- B+树：只有叶子节点才会存储数据，非叶子节点只存储键值key；叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。
- B+树的最底层叶子节点包含了所有的索引项

[https://developer.aliyun.com/article/831250](https://developer.aliyun.com/article/831250)

# 七、索引的数据结构及在存储引擎中的实现

MySQL索引使用的数据结构主要为B+Tree。但是根据存储引擎的不同，实现方式也不同

## 7.1 MyISAM:

B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在， 则根据data域中磁盘地址到磁盘中寻址定位到对应的磁盘块，然后读取相应的数据记录，这被称为“非聚簇索引”。

除非主键索引外，剩下的都可以叫做辅助索引。 在MyISAM存储引擎中辅助索引的数据结构和主键索引是完全一致的。他叶子节点的data域存的也是数据对应的地址。 但是辅助索引是可以出现重复数据的。

## 7.2 InnoDB：

其数据文件本身就是索引文件。相比MyISAM（索引文件和数据文件是分离的），其表数据文件本身就是按照B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。
这个索引的Key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址， 这也是和MyISAM不同的地方

> 说明：
> - 在根据主索引搜索时，直接找到Key所在的节点即可取出数据；
> - 在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。
> - 因此在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

对于不建议使用非单调的数字作为主键。 这样会造成数据页频繁分裂。 请参考以下例子进行理解。

让我们来看一个例子。假设我们有1到100个数字，以及10个盒子，每个盒子可以装下10个数字。我们将这10个盒子视为数据页。
首先，让我们看看当数据以单调递增的顺序插入时会发生什么。我们将数字1到10插入第一个盒子中，然后将数字11到20插入第二个盒子中，依此类推。在这种情况下，不会发生数据页分裂，因为每个盒子都被填满了，但没有溢出。
现在，让我们看看当数据以非单调的顺序插入时会发生什么。假设我们先将数字1、11、21、31、41、51、61、71、81和91插入第一个盒子中。然后，我们尝试将数字2插入第一个盒子中。由于第一个盒子已经被填满了，所以会发生数据页分裂。这意味着第一个盒子中的一部分数据会被移动到一个新的盒子中，以便为数字2腾出空间。
接下来，如果我们尝试将数字12插入第一个盒子中，同样会发生数据页分裂。这样，每当我们尝试将一个新数字插入第一个盒子中时，都会发生数据页分裂。 因此，在这个例子中，当数据以非单调的顺序插入时，数据页分裂的频率要高得多。

### 7.2.1 InnoDB的主键索引（聚簇索引)

每个InnoDB表都有一个聚簇索引，聚簇索引使用B+树构建，叶子节点的data阈存储的是整行记录。一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引。InnoDB创建索引的具体规则如下：

1. 在创建表时，定义主键PRIMARY KEY，InnoDB会自动将主键索引用作聚簇索引。
2. 如果表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引。
3. 如果以上两个都没有，InnoDB会自动使用一个长度为6字节的ROWID字段来构建聚簇索引，该ROWID字段会在插入新的行记录时自动递增。

### 7.2.2 InnoDB的辅助索引（非聚簇索引）

除聚簇索引之外的所有索引都被称为辅助索引(比如普通索引、唯一索引等)。在InnoDB中，辅助索引中的叶子节点键值存储的是该行的主键值。在检索时，InnoDB使用此主键在聚餐索引中搜索行记录。
在辅助索引树中获取到主键id，再根据主键id到主键索引数中检索数据的的过程称为回表查询。

### 7.2.3 InnoDB的组合索引

组合索引是由多个字段共同组成的索引。 其最终构建出来的索引结构和创建索引时字段的顺序有关。因此。创建组合索引时任的顺序是否更加契合业务场景会决定当前组合索引的查询效率。

#### 7.2.3.1 最左匹配原则

最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。

在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排序，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内有序递增；而clie只能在a和b两列值相等的情况下小范围内有序递增。

就像上面的查询，B+ 树会先比较a列来确定下一步应该检索的方向，往左还是往右。如果a列相同再比较b列，但是如果查询条件中没有a列，B+树就不知道第一步应该从那个节点开始查起。

可以说创建的idx_(a，b，c)索引，相当于创建了(a)、(a，b)、(a，b，c)三个索引。

> 注意：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(>、<、between、like)等就会停止匹配。也就是说。 在范围条件查询的右边的索引字段会失效。

组合索引的创建技巧：在创建联合索引的时候应该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选力度大，这些都是在创建索引的时候需要考虑到的优化场景，也可以将常需要作为查询返回的字段增加到联合索引中。

# 八、覆盖索引

**覆盖索引并不是一种索引结构，覆盖索引是一种很常用的优化手段**。因为在使用辅助索引的时候，我们只可以拿到相应的主键值，想要获取最终的数据记录，还需要根据主键通过主键索引再去检索，最终获取到符合条件的数据记录。
在上面的abc_innodb表中的组合索引查询时，如果我们查询的结果只需要a、b、c这三个字段，那我们使用这个idx_index(a，b，c)组合索引查询到叶子节点时就可以直接返回了，而不需要再次回表查询，这种情况就是**覆盖索引**。

# 九、索引选择性

索引选择性是指索引中不重复的索引值与表中总行数之间的比率。它反映了索引中不同值的多样性程度。选择性越高，表示索引值的重复程度越低，即索引值在列中的唯一性更高。

索引选择性对索引的效果有重要影响。以下是影响因素：

1. 查询性能：选择性高的索引通常具有更好的查询性能。当查询条件使用了索引列时，高选择性的索引可以更有效地过滤出所需的数据行，减少磁盘I/O和CPU开销。

2. 索引大小：选择性越高，索引中的不同值越多，索引的大小也会相应增加。高选择性的索引可能占用更多的磁盘空间，对于大型数据库来说，需要权衡存储空间和查询性能之间的平衡。

3. 更新性能：选择性较低的索引在进行插入、更新和删除操作时可能会引发数据页的频繁分裂和合并，导致更新性能下降。选择性高的索引可以减少数据页的频繁调整，提高更新性能。

> 说明： 结合索引选择性。在实际不断调试的过程中，对索引进行优化。

# 九、注意事项

1. 索引并不是越多越好，过多的索引可能会影响数据的插入、更新和删除操作的性能，甚至可能导致索引失效。
2. 对于较小的表或经常进行全表扫描的查询，不应该创建索引，因为这会增加额外的开销，反而会降低查询效率。
3. 对于经常用于查询的列，应该创建索引，以提高查询效率。
4. 在设计索引时应该考虑查询的频率、查询条件的复杂度、表的大小等因素，以达到最优的查询性能。
5. 索引本身很大
6. 数据量比较少的表，不建议创建索引

# 避免索引失效

- 低选择性：如果索引列的选择性非常低，即索引值重复较多，数据库优化器可能认为通过全表扫描获取数据的效率更高，而不使用索引。
- 使用函数或表达式：当查询中使用函数或表达式对索引列进行操作时，数据库无法直接使用索引，而需要对所有行进行计算，导致索引失效。
- 范围查询：对于范围查询（例如使用大于、小于、区间等条件）或模糊查询（例如使用LIKE关键字）时，索引的效果可能会降低，因为这些操作无法精确匹配索引值。
- 隐式类型转换：如果查询中的条件与索引列的数据类型不匹配，数据库可能会进行隐式类型转换，导致索引失效。
- 复合索引，遵循最佳做前缀原则，不要跨列或乱序使用；反之索引失效
- 不要再索引上进行函数调用、逻辑运算、类型转换等操作，否则索引失效
- 复合索引，不要使用 `!= 、 <> 、is null、is not null` 运算符，否则自身及右侧索引失效
- 尽量使用覆盖索引
- 范围查询 in、between、>、<、>=、<=、可能会导致索引失效
- like查询，如果以%开头，索引失效
- 不要使用类型转换，包括隐式转换和显式转换，否则索引失效
- 不要使用or，否则索引失效
- exist和in的使用：如果主查询数据集大，则用in。如果子查询结果集大就用exist

> 提问与思考

这个说法。无法说服我。即使数据库，他认为我函数的返回结果可能不是固定的。那将函数的返回结果。拿到索引数据结构中去进行匹配。这个匹配过程的效率应该是要比不使用索引要高的吧。即使。函数的返回结果不固定。他在索引匹配的过程中。如果没有匹配到结果，那在全表扫描的时候肯定也是没有结果的呀。这种情况下数据库为什么会选择放弃使用索引呢？他最根本的原因和逻辑是什么？
您的观点是正确的。但是，数据库索引是基于索引字段的原始值建立的。当您在查询条件中对索引字段使用函数时，数据库会认为索引字段的值已经被更改，因此无法使用索引。这是因为数据库无法确定函数对索引字段的影响，也无法确定函数返回的结果是否与索引数据结构中的值匹配。因此，为了保证查询结果的准确性，数据库会选择放弃使用索引，而进行全表扫描。
如果您希望在查询条件中使用函数并且仍然能够使用索引，可以考虑在创建索引时使用函数索引。函数索引是针对函数计算后的值建立的索引，这样就可以通过扫描索引来查询数据了。不过，目前并不是所有数据库系统都支持函数索引。

回答： 您的观点是正确的。但是，数据库索引是基于索引字段的原始值建立的。当您在查询条件中**对索引字段使用函数（这个点重点理解下，是对索引字段使用函数）**
时，数据库会认为索引字段的值已经被更改，因此无法使用索引。这是因为数据库无法确定函数对索引字段的影响，也无法确定函数返回的结果是否与索引数据结构中的值匹配。因此，为了保证查询结果的准确性，数据库会选择放弃使用索引，而进行全表扫描。
如果您希望在查询条件中使用函数并且仍然能够使用索引，可以考虑在创建索引时使用函数索引。函数索引是针对函数计算后的值建立的索引，这样就可以通过扫描索引来查询数据了。不过，目前并不是所有数据库系统都支持函数索引。

```sql
-- 对索引字段使用函数
SELECT *
FROM my_table
WHERE UPPER(name) = 'JOHN';
```

# order by优化

- using filesort：表示查询结果需要一次额外的排序；排序有2种算法。
    - 双路排序：扫描2次磁盘，一次单独扫描排序字段，一次扫描所需查询的其他字段
    - 单路排序：将排序字段和其他字段一起扫描，然后排序。排序会在buffer中进行，如果buffer不够大，会导致排序失败，这时会使用双路排序。使用 max_length_for_sort_data
      参数来设置buffer的大小，。如果排序字段的长度超过了这个值，就会使用双路排序。
- 避免使用select *。使用select *会有一次额外的计算。并且会导致查询结果集变大（如果有些字段你不需要的话）
- 保证排序字段的一致性，要么都升序，要么都降序

# 慢sql排查

- 可以使用 SHOW VARIABLES LIKE 'slow_query_log' 命令来查看。如果未启用，可以使用 SET GLOBAL slow_query_log = ON 命令来启用它。

- 查看慢查询阈值。可以使用 SHOW VARIABLES LIKE 'long_query_time' 命令来查看。这个值表示超过多少秒的查询将被记录到慢查询日志中。

- 查看慢查询日志文件的位置。可以使用 SHOW VARIABLES LIKE 'slow_query_log_file' 命令来查看。

- 使用mysqldumpslow工具筛选具体的慢查询。例如：可以使用 mysqldumpslow -s t -t 10 /var/log/mysql/slow.log 命令来查看最耗时的10条查询。

# 海量数据分析

- profiles:
- profile:
- 全局日志：

profiles是一种性能分析工具，用于分析MySQL服务器的运行情况，包括查询执行时间、锁定等待时间、访问表的次数等，从而帮助用户定位性能瓶颈，优化数据库的性能。

```sql
-- 查看profiles是否开启
show variables like '%profiling%';
-- 开启profiles
SET profiling = 1;
-- 查看sql执行情况
SHOW PROFILES;
-- 针对某条sql查看执行情况
SHOW PROFILE ALL FOR QUERY <Query_ID>;

```