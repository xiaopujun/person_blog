# join语句的优化

# 一、查看sql执行计划 explain

```sql
explain
select *
from user
where id = 1;
```

使用explain关键字可以分析出sql语句的执行计划，是否使用了索引，是否使用了全表扫描等。

# 二、not in语句无法使用索引

```sql
-- not in 语句无法使用索引，查询效率降低
select name
from user
where id not in (1, 3, 4);
```

not in语句本质上是子查询，先执行子查询语句获取子查询结果集A，再判断外层查询语句中的每一行数据是否存在于结果集A中。如果存在则不返回，反之返回。

可以使用not exists语句替代not in语句，或者使用left join语句替代not in语句。

> 函数计算无法使用索引是因为函数计算结果的数据类型可能和检索的列值不是同一个数据类型，所以不能使用索引来加速查询，是这个意思吗？

是的，您的理解是正确的。函数调用的结果和索引列的值可能不是同一数据类型，这意味着MySQL不能直接使用函数调用结果来执行索引查找操作。因此，在使用函数调用的结果作为WHERE子句中的过滤条件时，MySQL无法使用索引来加速查询。

另外，即使函数调用的结果与索引列的值是相同的数据类型，MySQL也无法直接在索引列上使用函数调用的结果来执行索引查找操作。这是因为MySQL在索引列上执行查找操作时，只能使用等于、不等于、大于、小于、大于等于和小于等于这些操作符，而不能使用其他操作符。如果您使用了一个不能在索引列上使用的操作符，MySQL就无法使用索引来优化查询。


> MySQL中in和exists的本质区别是什么？查询过程差距在哪里

- in和exists都是用来判断一个值或者元组是否在一个子查询的结果集中，但是它们的执行方式不同。
- in是把外表和内表做join连接，然后比较外表的值是否在内表的结果集中。exists是对外表做循环，每次循环再对内表进行查询，并返回一个布尔值。
- 一般来说，如果子查询返回的结果集很大，那么exists会比in更快，因为exists只要找到一个匹配就会停止，而in要遍历所有的结果。如果子查询返回的结果集很小或者有索引，那么in和exists差别不大。
  另外，in只能用于单个值或者元组的比较，而exists可以用于复杂的条件判断。