## 1.5 事务

事务的标准特征（ACID）

考虑一个场景：账户A向账户B转200元

- 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的操作，要么全部成功，要么全部失败
- 隔离性：一个事务的操作在没有提交之前，对其他事务是不可见的；比如在没有提交前其他用户看A的账号，始终是没有少这200元的
- 一致性：数据库总是从一个一致性的状态转换到另一个一致性状态，如转账过程中，A账户的钱少了200，则B账户的钱应该要+200；反之就违背了一致性
- 持久性：一旦事务提交，所修改的数据就会永久的保存到数据库中

### 1.5.1 隔离级别

- 读未提交：该级别中，即使事务中的修改没有提交，对其他事务而言这个修改也是可见的；事务可以读取未提交的数据称为脏读
- 读已提交（不可重复读）：该级别解决了事务的隔离性问题（脏读），事务开启到提交前，所做的修改对其他事务都不可见；该级别也叫不可重复读，因为执行两次相同的查询可能会得到不同的结果；
- 可重复读：该级别保证了同一个事务中，多次读取同样记录的结果是相同的；这解决了不可重复读的问题；但无法解决幻读（事务A第一次读取表中记录的过程中事务B向表插入或删除记录，导致事务A再次读取记录时与第一次读取得到的记录数不一致）
- 串行化：最高隔离级别，它保证了每一个事务都是串行的执行，从而解决了幻读的问题

|隔离级别|产生脏读|产生不可重复读|产生幻读|
|---|---|---|---|
|读未提交|✅|✅|✅|
|读已提交|❌|✅|✅|
|可重复读|❌|❌|✅|
|串行化|❌|❌|❌|

### 1.5.2 死锁

死锁是指两个或多个事务占用自己资源不放，并请求锁定对方资源，从而导致循环等待的恶性现象；

### 1.5.3 事务日志

事务日志可以提交事务效率，使用事务日志，存储引擎在修改表数据的时候只需要修改它的内存副本，再把修改记录到持久在磁盘上的事务日志上，而不用每次都将数据本身持久化到磁盘上；事务日志采用的是追加的方式，因此效率较高；事务日志持久化后，数据真实的持久化过程可以在后台慢慢的刷到磁盘上；

### 1.5.4 MYSQL事务

mysql本身提供了两种事务引擎，InnoDB和NDB Cluster

#### 1.5.4.1 自动提交

mysql默认采用自动提交模式，如果不显示的开启一个事务，则每一个查询都被当作一个事务执行提交操作；

在当前连接中可以通过设置 autocommit 变量来开启或禁用自动提交模式

```sql
-- 查询自动提交状态
show
variables like 'autocommit';
-- 设置自动提交
set
autocommit = 1;
```

存在一些命令，在执行前会强制执行commit命令提交当前的活动事务，比如DDL（数据库定义语句）语句中 使用 alter table 便会触发自动提交；lock tables也是如此

#### 1.5.4.2 设置隔离级别

mysql可以通过如下命令设置事务的隔离级别，新的隔离级别会在下一个事务开启时生效；

```sql
set transaction isolation level read uncommitted;
```

也可以在配置文件中设置以对整个数据库生效；


> 警告：不要在事务中混合使用事务型表和非事务型表，这在事务回滚时，非事务型表的修改无法回滚，会造成数据不一致

#### 1.5.4.3 显示锁定和隐式锁定

InnoB存储引擎采用2阶段锁定协议，在事务的执行过程中，随时都可以执行锁定；锁只有在commit和rollback的时候才会释放；且所有的锁都是在同一时刻被释放；InnoB会根据隔离级别在需要的时候自动加锁；
这些自动操作是存储引擎自动的隐式的加锁行为；

除了隐式的锁，InnoB也支持通过语句显示的加锁

除了存储引擎，服务器层面的实现也支持如下格式的锁定方式；但这些锁定无法代替事务

```shell
lock tables;
unlock tables;
```

> 这些显示的使用锁的语句，不要和事务一起混用