# 单例模式

核心思想：保证一个类，只能有一个示例对象，并且提供一个访问该实例的公共方法。 

### 常见场景：

- 任务管理器
- 回收站
- 项目中读取配置文件的类，一般也是单例的，也就是只有一个对象
- 计数器
- 数据库连接池
- servlet编程中，servlet也是单例的
- spring中，默认每一个bean都是单例的。

### 单例模式的优点

由于单例模式只需生成一个实例，这样就大大节约了内存空间，提高了运行效率。

### 单例模式的5种实现方式

饿汉模式（线程安全，调用效率高，不能延时加载）

懒汉模式（线程安全，调用效率不高，可延时加载）

DCL懒汉式（由于JVM底层内部原因，偶尔会出现问题，不建议使用）

饿汉改进式：静态内部类式（线程安全，调用效率高，可以延时加载）

枚举单例（线程安全，调用效率高，不能延时加载） 

### 饿汉式单例模式

饿汉模式缺点：如果这个类种存在很多开辟内存空间的语句，那么就会造成性能不好，因为此时，一加载类，这些语句就会需要很多内存。但是又不一定用得到。

```java
/**
 * 饿汉式单例模式
 */
public class Demo01 {
    /**
     * 私有化构造器
     */
    private Demo01() {
    }
    /**
     * 类初始化时就创建对象并加载
     */
    private static Demo01 instance = new Demo01();

    /**
     * 提供一个public方法供外界获得对象
     */
    public Demo01 getInstance(){
        return instance;
    }
}
```

### 懒汉模式

缺点：性能较为下降

```java
/**
 * 懒汉式单例
 */
public class Demo02 {
    /**
     * 私有化构造器
     */
    private Demo02() {
    }

    /**
     * 类初始化时不创建对象
     */
    private static Demo02 instance;

    /**
     * 提供一个public方法供外界获得对象
     */
    public synchronized Demo02 getInstance() {
        if (instance == null) {
            instance = new Demo02();
        }
        return instance;
    }
}
```

### DCL懒汉式

双重检测机制，较普通懒汉式，性能有提升。

```java
/**
 * DCL懒汉式单例
 */
public class Demo03 {
    /**
     * 私有化构造器
     */
    private Demo03() {
    }

    /**
     * 类初始化时不创建对象
     */
    private static Demo03 instance;

    /**
     * 提供一个public方法供外界获得对象
     */
    public Demo03 getInstance() {
        if (instance == null) {
            synchronized (this) {
                if (instance == null) {
                    instance = new Demo03();
                }
            }
        }
        return instance;
    }
}
```

### 静态内部类饿汉改进式

```java
/**
 * DCL懒汉式单例
 */
public class Demo04 {
    /**
     * 私有化构造器
     */
    private Demo04() {
    }

    /**
     * 静态内部类
     */
    private static class innerClass {
        private static final Demo04 instance = new Demo04();
    }

    /** 
     * 提供公共方法供外部访问
     */
    public static Demo04 getInstance() {
        return innerClass.instance;
    }
}
```

