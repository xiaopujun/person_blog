# 1.说说多线程的理解

1. 与线程直接相关的物理硬件可以直接想到cpu、核心数
2. 目前一个cpu可以对应多个核心，每个核心理论上每个时刻只能执行一个线程在实时运行（超线程的除外）；
3. 多线程的本质是通过cpu在极短的时间内进行多个线程任务之间的切换以达到不同的任务能让人为感知上是看似并发执行的；
4. 多线程的最终目的是为了提高cpu核心的利用率；让运算资源能发挥最大的能效；

## 1.1 如果不使用多线程

1. 从用户感知上一个任务只能一条道走完其他任务才能开始；多个任务没法同时执行
2. 从计算资源上理解会造成计算资源的浪费；

# 2.如何保证线程安全

## 2.1 三种方式

### 2.1.1 原子类

java.util.concurrent.atomic包下的类，提供了原子操作，比如AtomicInteger、AtomicLong等；本质上是CAS

### 2.1.2 volatile

是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”，从而可以保证单个变量读写时的线程安全。可见性问题是由处理器核心的缓存导致的，每个核心均有各自的缓存，而这些缓存均要与内存进行同步。volatile具有如下的内存语义：当写一个volatile变量时，该线程本地内存中的共享变量的值会被立刻刷新到主内存；当读一个volatile变量时，该线程本地内存会被置为无效，迫使线程直接从主内存中读取共享变量。原子类和volatile只能保证单个共享变量的线程安全

### 2.1.3 锁机制

1. synchronized关键字：没有考虑到超时机制、非阻塞形式，以及多个条件变量
2. Lock接口：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）

## 2.2 线程安全的原因

由多线程并发修改共享变量引起的；可尝试以下方式避免线程安全问题：

- 程序设计里避免共享变量的出现
-

不可变设计，如果在并发环境中不得不设计共享变量，则应该优先考虑共享变量是否为只读的，如果是只读场景就可以将共享变量设计为不可变的，这样自然也不会出现线程安全问题了。具体来说，就是在变量前加final修饰符，使其不可被修改，如果变量是引用类型，则将其设计为不可变类型（参考String类）

- 并发工具 java.util.concurrent包提供了几个有用的并发工具类
    - Semaphore：就是信号量，可以控制同时访问特定资源的线程数量
    - CountDownLatch：允许一个或多个线程等待其他线程完成操作
    - CyclicBarrier：让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续运行
-

本地存储,考虑使用ThreadLocal存储变量，ThreadLocal可以很方便地为每一个线程单独存一份数据，也就是将需要并发访问的资源复制成多份。这样一来，就可以避免多线程访问共享变量了，它们访问的是自己独占的资源，它从根本上隔离了多个线程之间的数据共享。

## 2.3 消耗资源率

原子类 < volatile < 锁

# 3. 谈谈Java反射

两个概念：

- 编译时环境
- 运行时环境

多态情况下Car c = new Audi(); 这行代码运行时会生成一个c变量,在编译时该变量的类型是Car,运行时该变量类型为Audi

java反射的目的是为了在运行时环境下实现一些动态的，特殊的需求

# 4. 说说ArrayList和LinkedList的区别
