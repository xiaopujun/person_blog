## java面向对象编程的三大特征：

1. 封装：封装隐藏了内部的实现机制，可以在不影响使用的情况下，任意改变内部的实现。只要接口调用方式和参数不变。调用方不必关心内部的实现逻辑。比如
    1. 集装箱
    2. 饮水机 一个好的封装，可以让程序易于修改，并能增强代码的可维护性

2. 继承：在java中是父类和子类之间的关系。子类可以复用父类中已有的属性和方法。
    1. 继承可以增加代码的复用性，减少代码量


3. 多态：多态指的是类和类之间的关系。第一要有父类，继承父类。第二要有重写。第三要有父类引用指向子类对象。
    1. 多态的好处在于其能很好的实现程序的扩展

## ArrayList和LinkList的区别

1. ArrayList 底层数据接口使用数组，LinkList底层数据结构使用链表
2. 基于数组的访问元素效率高，插入删除效率低。基于链表的插入，删除效率高。访问效率低

## 高并发的集合有哪些问题

![img.png](img.png)
![img_1.png](img_1.png)

## jdk8有哪些新特性

1. 接口的默认方法，兼容lamda表达式，接口中可以有方法实现
2. lamda表达式，简化编码

## 接口和抽象类各自的特征以及两者的区别，分别适合在什么场景使用

### 抽象类

1. 抽象类（包括抽象方法）使用abstract关键字进行定义
2. 抽象类的定义本质上是为了子类去继承它
3. 抽象类中可以有普通的成员变量以及普通的方法
4. 抽象类不能创建对象实例（原因在于其内部有未实现的方法）
5. 抽象类的抽象方法必须被子类实现，若不实现则其子类也必须为抽象类

### 接口

1. 接口允许定义普通成员变量，但该变量只能是public static final
2. 接口定义的方法只能是抽象方法 （jdk1.8后允许有默认方法的实现）

### 语法上：

1. 抽象类使用abstract关键字定义，接口使用interface关键字定义
2. 抽象类可以有普通方法，接口只能有抽象方法
3. 抽象类中的方法可以是任意类型的，接口中的方法只能是public abstract类型
4. 抽象类用于继承且只能单继承，接口用于实现且可以多实现

### 设计思想上：

1. 接口的设计是为了规范类的行为，定义统一的行为规范
2. 抽象类的设计是为了统一子类的共性，当多个类都具有相同的属性和行为，则将它抽取为抽象类
3. 接口相较于抽象类是一种范围较窄（大部分只抽象行为）单抽象层次更高的设计方案

### 使用场景上：

1. 接口的设计和规划一般在具体编码前。设计好该接口的所有具体行为，后续编码遵守该行为规范
2. 抽象类可两头进行，既可提前设计定义子类的统一共性。也可在后续编码过程中发现子类共享后进行抽象类的代码复用
3. 总体上接口是一种自上而下的编码行为。抽象类是自下而上的代码抽取和统一

## 为什么使用HashMap，插入的key为引用类型的时候要重写hashcode和equals
1. hashMap的插入和查找的时候需要通过key进行散列寻址值和对比拿到的value值
2. 散列寻址的操作需要先拿到key的hashCode值，如不复写hashCode方法，则不通的对象其hashCode基本不相同
3. value值对比需要通过equals方法进行对比，如不复写，则默认使用Object的equals进行对比，本质上还是比较地址是否相等

## java代理的几种实现方式

## ==和equals的区别

### ==

1. 对于基本数据类型和引用数据类型，==比较的是双方的内存地址是否相等，相等则返回true

### equals

1. equals只能用于引用类型的比较，默认情况下equals比较的也是双方的内存地址是否相等。
2. 若类本身复写类Object的equals，则使用的时候是用自己复写实现的规则进行比较

## java里的异常处理机制是怎么样的

## 重写和重载的区别
### 重写（复写）
1. 重写发生在子类与父类之间，是子类重新实现父类中的同名方法
2. 要求子类复写的方法与父类的
    1. 方法签名相同
    2. 方法参数个数、类型、顺序一致
    3. 方法的返回值必须与父类相同或者是父类返回类型的子类
    4. 方法访问权限必须>=父类
    5. 抛出的异常要么和父类方法异常一致，要么小于父类方法异常

### 重载

1. 发生在同一个类中
2. 要求方法签名相同
3. 方法形参的类型、顺序、个数之一要不同
4. 方法的返回值可以可以相同或不同
5. 访问修饰符可以不一致

## String、StringBuffer、StringBuilder及其使用场景

### String
1. 每次新建字符串都会创建一个新的对象，因此比较消耗性能
2. 线程不安全

### StringBuffer
1. 字符串的拼接都在一个对象中进行
2. 线程安全，方法内部都使用类synchronized进行方法同步

### StringBuilder
1. 字符串的拼接都发生在一个对象内
2. 线程不安全

总体效率： StringBuilder > StringBuffer > String

### 使用场景

1. 少量字符串拼接，使用String
2. 大量拼接使用StringBuilder或者StringBuffer。
3. 线程安全选StringBuffer，反之用StringBuilder

## 怎么声明一个类不会被继承，什么场景下会用

## 自定义异常如何在生产中使用