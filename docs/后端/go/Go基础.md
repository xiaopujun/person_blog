# Go语言中的引用传递和值传递

在 Go 语言中，确实有一些类型在作为函数参数时是引用传递，而其他大多数类型默认是值传递。具体来说：

1. **引用传递**：
    - **切片**：传递的是切片的引用，函数内部对切片的修改会影响到原切片。
    - **映射（map）**：传递的是映射的引用，函数内部对映射的修改会影响到原映射。
    - **通道（channel）**：传递的是通道的引用，函数内部对通道的操作会影响到原通道。
    - **接口（interface）**：接口本质上是一个指针，传递的是接口的引用。

2. **值传递**：
    - **数组**：传递的是数组的副本，函数内部对数组的修改不会影响到原数组。
    - **结构体**：传递的是结构体的副本，函数内部对结构体的修改不会影响到原结构体。
    - **基本类型**（如 int、float、bool、string 等）：传递的是值的副本，函数内部对这些值的修改不会影响到原值。

如果你希望函数能够修改原始值，可以使用指针传递。通过传递指针，函数内部对指针指向的值的修改会影响到原始值。

希望这些信息对你有帮助！如果还有其他问题，随时问我哦。

# Go语言中new和make函数的区别

在Go语言中，`new`和`make`是两个用于内存分配和初始化的内置函数，但它们有不同的用途和适用场景。

### `new`函数
- **作用**：`new`用于分配内存，但不初始化内存。它返回一个指向该类型零值的指针。
- **适用场景**：适用于创建值类型（如数组、结构体等）的指针。
- **示例**：
  ```go
  package main
  import "fmt"

  func main() {
      numPtr := new(int) // 创建一个int类型的零值变量的指针
      fmt.Println(*numPtr) // 输出0
  }
  ```

### `make`函数
- **作用**：`make`用于创建并初始化引用类型（如切片、映射和通道）。
- **适用场景**：适用于创建和初始化切片、映射和通道等引用类型。
- **示例**：
  ```go
  package main
  import "fmt"

  func main() {
      slice := make([]int, 3) // 创建并初始化长度为3的切片
      fmt.Println(slice) // 输出[0 0 0]
  }
  ```

### 区别总结
- **返回值**：`new`返回指针，而`make`返回初始化后的引用类型。
- **适用类型**：`new`适用于任意类型，而`make`仅适用于引用类型。
- **初始化**：`new`分配内存但不初始化，`make`分配并初始化内存¹².

希望这些信息对你有帮助！如果你有更多问题，随时问我哦。 😊

¹: [深入理解 Go 中的 new() 和 make() 函数 - SegmentFault 思否](https://segmentfault.com/a/1190000044249084)
²: [终极对决：Go语言make和new完整比较 - 阿里云开发者社区](https://developer.aliyun.com/article/1353563)

源: 与 Copilot 的对话， 2024/9/22
(1) 深入理解 Go 中的 new () 和 make () 函数 - SegmentFault 思否. https://segmentfault.com/a/1190000044249084.
(2) 终极对决：Go语言make和new完整比较 - 阿里云开发者社区. https://developer.aliyun.com/article/1353563.
(3) Go语言make和new的区别 - 知乎. https://zhuanlan.zhihu.com/p/486998884.
(4) 深入理解 Go 中的 new() 和 make() 函数-阿里云开发者社区. https://developer.aliyun.com/article/1579418.
