# 一、sql执行计划 explain

```sql
explain
select *
from student
where id = 1;
```

## 1.1 explain输出说明

|字段|说明|
|---|---|
|id| SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符。id值如果相同，从上往下顺序执行|
|select_type| SELECT 查询的类型.|
|table| 查询的是哪个表|
|partitions| 匹配的分区|
|type| join 类型|
|possible_keys| 此次查询中可能选用的索引|
|key_len| 索引长度|
|key| 此次查询中确切使用到的索引.|
|ref| 哪个字段或常数与 key 一起被使用|
|rows| 显示此查询一共扫描了多少行. 这个是一个估计值.|
|filtered| 表示此查询条件所过滤的数据的百分比|
|extra| 额外的信息|

## 1.2 id

1. id如果相同，从上往下顺序执行。（数据量越小的表越先执行，位置越靠上）
2. id如果不同，id越大的越先执行

## 1.3 select_type

select_type表示查询的类型，其值有如下：

|值|说明|
|---|---|
|SIMPLE|简单查询，不包含子查询或UNION。|
|PRIMARY|包含复杂的子查询，最外层查询标记为该值。|
|SUBQUERY|在SELECT或WHERE中包含子查询，被标记为该值。|
|DERIVED|在FROM中包含子查询，被标记为该值。(如果form子查询中只有一个表，则该表就是衍生表，如果有多个表，则左表就是衍生表)|
|MATERIALIZED|表示子查询被物化。这意味着MySQL会先执行子查询，然后将结果存储在临时表中，再使用临时表来执行外部查询。|
|UNCACHEABLE SUBQUERY|一个子查询的结果不能被缓存，必须重新评估外链接的第一行。|
|UNCACHEABLE UNION|第二个或后续的SELECT语句属于不可缓存的UNION。|
|DEPENDENT SUBQUERY|一个子查询，它依赖于外部查询的结果，并且可能对每个行重新评估。|
|DEPENDENT UNION|第二个或后续的SELECT语句属于依赖于外部查询的结果的UNION。|
|UNION RESULT|从前面的UNION表中检索结果。|
|UNION|第二个或后续的SELECT语句属于UNION。|

## 1.3 type

在MySQL中，EXPLAIN语句的结果中的type字段表示MySQL在表中找到所需行的方式， 也称为“访问类型”。根据性能从优到劣， type字段的取值依次为：NULL > system > const > eq_ref > ref >
range > index > all。

一般手动优化达到ref级别

|值|说明|
|---|---|
|NULL| MySQL 不用访问表或者索引就直接能到结果。|
|system| 表示查询的表只有一行记录（等于系统表），这是const类型的特例，即系统表。|
|const| 用主键索引或唯一索引，且只查到一条数据就能达到该级别。表示通过索引一次就找到了。因为只匹配一行数据，所以很快。|
|eq_ref| 表示唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引。|
|ref| 表示非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的行，但是可能会找到多个符合条件的行，所以速度比eq_ref慢。|
|range| 表示只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在你的where语句中出现了between、<、>、in(有时候会失效，退化为无索引)等的查询。|
|index| 表示全索引扫描(full index scan)，和all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘读取的）|
|all| 表示全表扫描，这种情况下MySQL将遍历全表以找到匹配的行。|

## 1.4 possible_keys

表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到. key_len 的计算规则如下:

- 字符串
    - char(n): n 字节长度
    - varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.
- 数值类型:
    - TINYINT: 1字节
    - SMALLINT: 2字节
    - MEDIUMINT: 3字节
    - INT: 4字节
    - BIGINT: 8字节
- 时间类型
    - DATE: 3字节
    - TIMESTAMP: 4字节
    - DATETIME: 8字节
- 字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.

## 1.5 extra

|值|说明|
|---|---|
|Using filesort|说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序读取。MySQL无法利用索引完成的排序操作称之为文件排序，常见于order by排序1。|
|Using temporary|表示MySQL在对查询结果排序时使用临时表。常见于多表join语句。|
|Using index|表示查询的内容可以直接在索引中拿到，也就是所谓的“覆盖索引”。|
|Using where|表示使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。|
|Using join buffer|表示使用了连接缓存。|
|Impossible where|表示WHERE子句总是false，不能用来获取任何元组。|
|Select tables optimized away|在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成阶段即可完成优化。|

# 二、MySQL中select语句的解析顺序

form -> on -> join -> where -> group by -> having -> select -> distinct -> union -> order by -> limit

# 二、子查询优化

MySQL中应尽量避子查询，

- 子查询可能会产生临时表，临时表会影响性能
- 在超大数据量的情况下，如果每次都执行一次子查询，会影响性能
- 实际执行结果应该查看explain的执行计划

# 三、范围查询优化

在 MySQL 中，哪种查询方式最有效和最快速取决于许多因素，包括数据量、索引的使用、服务器的硬件配置等。因此，不能一概而论地说某一种查询方式一定比其他方式更快。 但是，以下是一些常见的查询方式及其适用场景：

- BETWEEN：适用于范围查询，例如查询在某个日期范围内的数据。如果表上有索引，那么 BETWEEN 可能是最快的方式，因为它可以利用索引的范围查找功能，只扫描符合条件的行。


- < 和 >：适用于单个值查询，例如查询所有大于某个值的数据。如果表上有索引，那么这些操作也可以利用索引进行快速查找。


- IN：适用于查询多个值，例如查询某个状态的多个数据。但是，当 IN 子句中的值数量较大时，可能会影响查询性能。


- OR：适用于查询多个条件，例如查询状态为 A 或状态为 B 的数据。但是，如果查询中包含多个 OR 子句，或者其中一个子句返回的数据很多，那么查询的性能可能会受到影响。


- not in：尽量避免使用，无法走索引

# 四、分页查询优化

# 五、排序查询优化

# 六、分组查询优化

# 七、数据类型优化

# 八、查询结构优化

# 九、链接查询优化

# 十、索引优化

# 十一、其他优化

# not in语句无法使用索引

```sql
-- not in 语句无法使用索引，查询效率降低
select name
from user
where id not in (1, 3, 4);
```

not in语句本质上是子查询，先执行子查询语句获取子查询结果集A，再判断外层查询语句中的每一行数据是否存在于结果集A中。如果存在则不返回，反之返回。

可以使用not exists语句替代not in语句，或者使用left join语句替代not in语句。

> 函数计算无法使用索引是因为函数计算结果的数据类型可能和检索的列值不是同一个数据类型，所以不能使用索引来加速查询，是这个意思吗？

是的，您的理解是正确的。函数调用的结果和索引列的值可能不是同一数据类型，这意味着MySQL不能直接使用函数调用结果来执行索引查找操作。因此，在使用函数调用的结果作为WHERE子句中的过滤条件时，MySQL无法使用索引来加速查询。

另外，即使函数调用的结果与索引列的值是相同的数据类型，MySQL也无法直接在索引列上使用函数调用的结果来执行索引查找操作。这是因为MySQL在索引列上执行查找操作时，只能使用等于、不等于、大于、小于、大于等于和小于等于这些操作符，而不能使用其他操作符。如果您使用了一个不能在索引列上使用的操作符，MySQL就无法使用索引来优化查询。


> MySQL中in和exists的本质区别是什么？查询过程差距在哪里

- in和exists都是用来判断一个值或者元组是否在一个子查询的结果集中，但是它们的执行方式不同。
- in是把外表和内表做join连接，然后比较外表的值是否在内表的结果集中。exists是对外表做循环，每次循环再对内表进行查询，并返回一个布尔值。
- 一般来说，如果子查询返回的结果集很大，那么exists会比in更快，因为exists只要找到一个匹配就会停止，而in要遍历所有的结果。如果子查询返回的结果集很小或者有索引，那么in和exists差别不大。
  另外，in只能用于单个值或者元组的比较，而exists可以用于复杂的条件判断。




in条件一般放到where语句最后，防止in导致的索引失效